- ## HTTP 史记

  - **http 1.0**: 无连接，且在浏览器端存在队头阻塞。
  - **http 1.1**: 支持持久连接，将队头阻塞转移到服务器端，减少了数据传输的延迟，与此同时还引入了 HTTP 头部的缓存机制。
  - **http 2.0**: 利用二进制分帧的特性实现多路复用，并引入了头部压缩与服务器推送等技术。

  ### http 1.0

  - **无连接**：默认情况下，每个 HTTP 请求都会创建一个新的 TCP 连接，并且在请求完成后关闭此连接，这导致了较高的延迟和较低的效率（每个 HTTP 请求都需要进行 TCP 握手与挥手），尤其是在网页包含多个资源时。
  - **不支持管道化**：同一时间浏览器只能处理一个请求，后续请求必须等待前面的请求响应结束才能发送，这意味着如果一个请求如果没有得到响应，那么后续的所有请求都会被阻塞，这就是常说的“**队头阻塞**”💥。

  ### http 1.1

  - **长连接**：引入 `Connection: keep-alive` 机制，允许单个 TCP 连接处理多个 HTTP 请求，减少了频繁握手与挥手带来的开销。
  - **支持管道化**：客户端能够向服务器发送多个请求，服务器端可以同时处理这些请求，但是需要按照请求的顺序依次响应，以便客户端能够区分每次请求的响应内容。这意味着如果一个请求没有处理完毕，哪怕后面的请求已经准备就绪，也会被服务器所阻塞，事实上这只不过将队头阻塞转移到了服务器端。
  - **缓存**：在 HTTP 头部中新增 `Cache-Control`、`Expires`、`Last-Modified` 等字段，用于指定资源的缓存策略。

  ### http 2.0

  - **二进制分帧**：http 2.0 采用**二进制格式**传输数据，而非文本格式，并且 http 2.0 还将请求和响应分割为多个帧，以便支持多路复用。
  - **多路复用**：由于二进制分帧的特性，多个请求和响应能够在同一个连接上交错进行，接收方只需要根据帧上的流标识符即可将其组装为正确且完整的消息。**由于不再关心请求和响应的先后顺序，因此可以解决“队头阻塞”问题**。
  - **头部压缩**📦：对一些重复的 HTTP 头部字段（例如 cookie 等）进行压缩，以减少传输的流量。实现原理类似于双方协商一个编码表，然后对 HTTP 头部进行编码，最后在传输过程中解码，例如使用 'A' 来代指 Last-Modified。
  - **服务器推送**：服务器可以主动向客户端推送数据，而无需客户端发送请求。例如在用户请求 HTML 文件时，服务器就可以将对应的 CSS 文件和 JS 文件发送给客户端，而不必等待浏览器解析到相应位置时再发送请求。

  ### HTTP 3

  HTTP 3 是基于 QUIC（Quick UDP Internet Connection）协议实现的，事实上 HTTP 3 的主要作用就是保持 HTTP 基本语义，很多 http 2 的功能都移交给 QUIC 了。那么 QUIC 协议具有哪些特点呢？

  - **解决 TCP 层面的队头阻塞**： TCP 队头阻塞其实与 ACK 有一定的关系，后续的数据包需要等待前面的数据包的 ACK，这就导致了“队头阻塞”。QUIC 采用的解决办法与 http 2 的思想类似，就是为数据分配一个标识符，根据标识符来区分不同的数据包，从而不必进行排队等待 。
  - **整合 TCP 握手与 TLS 握手**：在 http 2 之中传递数据需要经过 TCP 握手与 TLS 握手，至少需要 2 RTT 才能进行数据传输，而在 QUIC 中，这两个步骤可以合并为一个步骤，从而减少了 RTT 的数量 ⚡。
  - **Connection ID 实现切网不重握**：通常情况下，发生网络切换（例如从 WIFI 切到 4G）时，浏览器需要进行重新握手连接。QUIC 引入 Connection ID，通过 Connection ID 将不同网络的请求与响应关联起来 🦄，从而实现切网不重握。 
