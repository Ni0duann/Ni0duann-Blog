## 强缓存

强缓存的实现方案主要是有两种：`Expires` 和 `cache-control`

- `Expires`：过期时间，如果设置了过期时间，则浏览器会在过期时间内使用缓存。Expires 是 HTTP1.0 的产物，受限于本地时间，如果人为修改了本地时间，可能会造成缓存失效。
- `cache-control`：缓存控制，常用有以下几个设置：
  - `max-age`：表示缓存可以使用多长时间，是一个相对时间
  - `public`：表示响应可以被任何区缓存
  - `private`：只针对个人用户，不可被代理服务器缓存
  - `no-cache`：可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用，强制客户端总是向服务器发送请求，由服务器判断缓存是否可用，即总是启用协商缓存
  - `no-store`：彻底禁用缓存，每次都需要从服务器获取资源，流量消耗增加

`Expires` 和 `cache-control` 都可以实现强缓存



## 协商缓存

- `Etag/If-None-Match`：
  - `Etag`：这个字段是由服务器生成返回给浏览器的，它的值是由文件的索引节点（INode）、文件大小（size）、文件最后修改时间（MTime）进行hash之后得到的
  - `If-None-Match`：再次请求该资源时，带上上一次服务器返回的`ETag`值

过程：当强缓存过期，浏览器会启用协商缓存，首先判断当前是否存在`ETag`，如果存在，则再次向服务器发送请求时，在请求头上加上`If-None-Match`一同发送到服务器，服务器比对当前的`If-None-Match`与资源相对应的`ETag`是否相同，如果相同则说明缓存可用，则返回304，否则返回最新的资源。

- `Last-Modified/If-Modified-Since`：
  - `Last-Modified`：服务器返回的文件最后修改时间
  - `If-Modified-Since`：再次请求资源是，带上上一次服务器返回的`Last-Modified`值

过程：当资源过期时，如果不存在`ETag`而是存在`Last-modified`，则再次向服务器发送请求时，在请求头上会带上`If-Modified-Since`一同发送给服务器，服务器对比资源最后修改时间和当前客户端发送的`If-Modified-Since`这个时间，判断资源是否被修改，如果修改了则返回最新的资源，如果没有修改则返回304，使用缓存。

**`ETag`的优先级高于`Last-Modified`,服务器会优先验证`ETag`**

**`Last-Modified`是以秒为单位的，所以在资源频繁更改的情况下，`Last-Modified`是不安全的，而`ETag`可以检查文件大小和文件的唯一索引节点，故即使修改频繁的资源依然能检测到更改**

